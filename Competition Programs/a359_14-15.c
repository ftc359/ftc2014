#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S2,     _SMUX,          sensorI2CCustom)
#pragma config(Sensor, S3,     light,          sensorLightInactive)
#pragma config(Sensor, S4,     tMUX,           sensorHiTechnicTouchMux)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     lift,          tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    dragger,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    scorer,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Assets\Headers\h359_14-15.h"
#include "Assets\Headers\Autonomous_Funcs.h"

long waitDuration;
long intercept;

bool ramp = true;
bool fill;
bool kickstand = false;
bool fill2;
bool centerScore = false;

int centerRotation; //1 = kickstand facing alliance PZ, 2 = 45, 3 = 90

task timer(){
	wait10Msec(3000);
	playSound(soundBeepBeep);
	wait1Msec(1000);
	stopAllTasks();
}

task main()
{
	configLine("Select Options: ");
	configLine("Intercept: ", &intercept, "ms", 0, 50, 5000);
	configLine("Wait: ", &waitDuration, "ms", 0, 50, 10000);
	configLine("", &ramp, "", "Ramp", "Parking Zone");
	configLine("KS: ", &kickstand, "", "Yes", "No");
	configLine("Score in: ", &centerScore, "", "CG", "RG");
	startDisplay(true, true);
	initializeRobot();
	waitForStart();
	//stopTask(readMsgFromPC);
	//startTask(timer);
	wait1Msec(waitDuration);
	if(intercept){
		move(100, intercept, fwd);
		return;
	}
	if(ramp){
		move(35, 1250, bwd); //drive off ramp
		readIR();
		moveLift(75, 2750);
		move(35, 2250, bwd); //drive towards goals
		readIR();
		wait1Msec(750);
		servo[scorer] = SCORER_OPEN_AUTO;
		wait1Msec(750);
		servo[scorer] = SCORER_CLOSE;
		centerRotation = ((ir_front_dir[0] == 5 || ir_front_dir[0] == 6 || ir_front_dir == 7) &&
		(ir_back_dir[0] == 5 || ir_back_dir[0] == 6 || ir_back_dir[0] == 7) &&
		(ir_front_dir[1] == 3 || ir_front_dir[1] == 4 || ir_front_dir[1] == 5) &&
		(ir_back_dir[1] == 3 || ir_back_dir[1] == 4 || ir_back_dir[1] == 5))?1:
		((ir_front_dir[0] == 0 || ir_front_dir[0] == 7) && (ir_back_dir[0] == 0 || ir_back_dir[0] == 7) && ir_front_dir[1] == 5 && ir_back_dir[1] == 5)?2:
		((ir_front_dir[0] == 0 || ir_front_dir[0] == 5) && (ir_back_dir[0] == 5 || ir_back_dir[0] == 6 || ir_back_dir[0] == 7) &&
		(ir_front_dir[1] == 0 || ir_front_dir[1] == 5 || ir_front_dir[1] == 6 || ir_front_dir[1] == 7) &&
		(ir_back_dir[1] == 0 || ir_back_dir[1] == 5 || ir_back_dir[1] == 6 || ir_back_dir[1] == 7))?3:0;
		displayString(3, "%d", centerRotation);
		displayString(4, "%d", ir_front_dir[0]);
		displayString(5, "%d", ir_back_dir[0]);
		displayString(6, "%d", ir_front_dir[1]);
		displayString(7, "%d", ir_back_dir[1]);
		//if(centerRotation == 0)
			//centerScore = false;
		if(centerScore){
			move(30, 500, right);
			move(35, 500, fwd);
			move(30, 1000, right);
			move(35, 1250, fwd);
			move(30, 1000, left);
			move(30, 3000, fwd);
			move(30, 1000, right);
			moveLift(90, 2000);
			switch(centerRotation){
				case 1:
					move(35, 3000, fwd);
					break;
				case 2:
					move(35, 2000, fwd);
					break;
				case 3:
					move(35, 1500, fwd);
					move(30, 900, left);
					move(30, 1500, bwd);
					wait1Msec(1000);
					servo[scorer] = SCORER_OPEN_CG;
					wait1Msec(1000);
					servo[scorer] = SCORER_CLOSE;
					break;
			}
			if(kickstand){
				//knock down kickstand
			}else{
			}
			//score in center goal and 60cm goal
			//drag back the goal
		}else{
			moveLift(-20, 1500);
			move(30, 500, right);
			move(50, 750, fwd);
			move(30, 750, right);
			move(30, 1250, fwd);
			move(30, 1000, left);
			move(30, 2500, bwd);
			move(30, 150, left);
			wait1Msec(1000);
			move(50, 150, left);
			wait1Msec(1000);
			servo[scorer] = SCORER_OPEN_CG;
			wait1Msec(1000);
			servo[scorer] = SCORER_CLOSE;
			//score in and drag 30cm
			if(kickstand){
				switch(centerRotation){
					case 1:
						move(35, 1000, fwd);
						move(30, 1250, left);
						move(30, 1000, fwd);
						move(30, 1000, right);
						move(30, 3000, fwd);
						move(30, 1250, right);
						move(100, 2000, fwd);
						break;
					case 2:
						move(30, 3000, fwd);
						move(30, 900, right);
						move(100, 2000, fwd);
						break;
					case 3:
						move(30, 1000, fwd);
						move(30, 1250, right);
						move(30, 1000, fwd);
						move(30, 1250, left);
						move(100, 2000, fwd);
						break;
				}
			}else{
			}
			//score in 90cm goal, drag back
		}
	}else{																				//Start in parking zone
		//drive off ramp
		//drive towards goals
		if(centerScore){
			//drag 60cm
		}else{
			//score in and drag 30cm
		}
		if(kickstand){
			//knock down kickstand
		}
		if(centerScore){
			//score in center goal and 60cm goal
			//drag back the goal
		}else{
			//score in 90cm goal, drag back
		}
	}
	while(true){}
}
