#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Sensor, S4,     tMux,           sensorHiTechnicTouchMux)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     lift,          tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    dragger,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    scorer,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//	Motors are reversed so that the back is considered the front for easier programming	//

#include "JoystickDriver.c"
#include "Assets\Headers\h359_14-15.h"
#include "Assets\Headers\Autonomous_Funcs.h"

long waitDuration;
bool ramp = true;
bool kickstand = true;
bool centerScore = true;

int irPos;
int centerRotation; //1 = kickstand facing alliance PZ, 2 = 45, 3 = 90

task main()
{
	configLine("Select Options: ");
	configLine("Wait: ", &waitDuration, "ms", 0, 50, 5000);
	configLine("", &ramp, "", "Ramp", "Parking Zone");
	//configLine("KS: ", &kickstand, "", "Yes", "No");
	configLine("Score in: ", &centerScore, "", "CG", "RG");
	startDisplay(true, true);
	initializeRobot();
	//waitForStart();
	//stopTask(readMsgFromPC);
	wait1Msec(waitDuration);
	startTask(state_machine);
	if(ramp){
		move(35, 2000, bwd); //drive off ramp
		//setSMstate(lift_move, 75, 1750);
		move(35, 1500, bwd); //drive towards goals
		if(centerScore){
			//drag 60cm
			servo[dragger] = DRAGGER_DOWN;
			if(kickstand){
				//knock down kickstand
			}else{
			}
			//score in center goal and 60cm goal
			//drag back the goal
		}else{
			servo[dragger] = DRAGGER_DOWN;
			servo[scorer] = SCORER_OPEN;
			wait1Msec(1000);
			servo[scorer] = SCORER_CLOSE;
			//setSMstate(lift_move, -10, 3500);
			move(35, 750, right);
			move(80, 3000, fwd);
			move(50, 3000, right);
			move(50, 2000, fwd);
			servo[dragger] = DRAGGER_UP;
			wait1Msec(100);
			move(50, 2000, bwd);
			move(50, 3000, left);
			//setSMstate(lift_move, 50, 5000);
			move(80, 3000, bwd);
			move(35, 500, left);
			move(50, 1000, fwd);
			motor[intake] = 100;
			wait1Msec(1500);
			servo[dragger] = DRAGGER_DOWN;
			servo[scorer] = SCORER_OPEN;
			wait1Msec(1000);
			servo[scorer] = SCORER_CLOSE;
			//score in and drag 30cm
			if(kickstand){
				//knock down kickstand
			}else{
			}
			//score in 90cm goal, drag back
		}
	}else{																				//Start in parking zone
		//drive off ramp
		//drive towards goals
		if(centerScore){
			//drag 60cm
		}else{
			//score in and drag 30cm
		}
		if(kickstand){
			//knock down kickstand
		}
		if(centerScore){
			//score in center goal and 60cm goal
			//drag back the goal
		}else{
			//score in 90cm goal, drag back
		}
	}
}
