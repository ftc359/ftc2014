#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     _gyro,          sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     _SMUX,          sensorI2CCustom)
#pragma config(Sensor, S4,     light,          sensorLightInactive)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     lift,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    dragger,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    scorer,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Assets\Headers\h359_14-15.h"
#include "Assets\Headers\Autonomous_Funcs.h"

#define HTSMUX_SENSORTYPE   0x10

long waitDuration = 0;
long intercept = 0;

int RG1 = 0;
int RG2 = 0;

bool CG = true;
bool fill1;
bool ramp = false;
bool fill2;
bool KS = true;

long KSwait = 0;

int centerRotation; //1 = kickstand facing alliance PZ, 2 = 45, 3 = 90

task liftTask(){
	busy = true;
	moveEncSingle(lift, target_power, target_distance, 1);
	busy = false;
}

void moveLift(int power, long distance){
	target_power = power;
	target_distance = distance;
	startTask(liftTask);
}

bool HTSMUXVerifyType(tSensors link){
    memset(HTSMUX_I2CRequest, 0, sizeof(tByteArray));
    HTSMUX_I2CRequest[0] = 2;
    HTSMUX_I2CRequest[1] = HTSMUX_I2C_ADDR;
    HTSMUX_I2CRequest[2] = HTSMUX_SENSORTYPE;

    if(!writeI2C(link, HTSMUX_I2CRequest, HTSMUX_I2CReply, 8))
        return false;

    if((char)HTSMUX_I2CReply[0] == 'S' && (char)HTSMUX_I2CReply[1] == 'e' &&
       (char)HTSMUX_I2CReply[2] == 'n' && (char)HTSMUX_I2CReply[3] == 's' &&
       (char)HTSMUX_I2CReply[4] == 'r' && (char)HTSMUX_I2CReply[5] == 'M' &&
       (char)HTSMUX_I2CReply[6] == 'U' && (char)HTSMUX_I2CReply[7] == 'X')

        return true;

    return false;
}

void selectStrategy();

task debug(){
	bool ruhroh = false;
	if (HTSMUXVerifyType(_SMUX) == false){
		nxtDisplayTextLine(0, "SMUX not connected");
		ruhroh = true;
	}
	if(HTSMUXreadPowerStatus(_SMUX)){
		nxtDisplayTextLine(1, "SMUX low batt");
		ruhroh = true;
	}
	if(ruhroh)
		playSound(soundBeepBeep);
	while(true){
		nxtDisplayTextLine(7, "H: %3.1f", heading);
		nxtDisplayTextLine(6, "D: %3.1f", deadband);
	}
}

task main()
{
	configLine("Intercept: ", &intercept, "ms", 0, 100, 7500);
	configLine("Wait: ", &waitDuration, "ms", 0, 100, 10000);
	configLine("RG1: ", &RG1, "cm", 0, 30, 90);
	configLine("RG2: ", &RG2, "cm", 0, 30, 90);
	configLine("", &ramp, "", "Ramp", "PZ");
	configLine("", &CG, "", "CG", "RG");
	configLine("KS: ", &KS, "", "Yes", "No");
	configLine("KS wait: ", &KSwait, "", 0, 100, 5000);
	startDisplay(true, true, "a359.txt");
	initializeRobot();
	servo[dragger] = DRAGGER_UP;
	servo[scorer] = SCORER_CLOSE;
	bSystemLeaveServosEnabledOnProgramStop = true;
	stopTask(displayDiagnostics);
	wait1Msec(1);
	eraseDisplay();
	wait1Msec(1000);
	calibrateGyro(&gyro, 100);
	startTask(gyroGetHeading);
	startTask(debug);
	//waitForStart();
	stopTask(readMsgFromPC);
	wait1Msec(waitDuration);
	if(intercept){
		move(100, intercept, fwd);
		return;
	}
	heading = 0.0;
	selectStrategy();
}

void selectStrategy(){
	if(ramp){
	}else{
		if(CG){
			moveEnc(35, 1000, 15, fwd);
			turn_gyro(60, -90.0, 0.5);
			readIR();
			/*moveEnc(35, 1000, 10, fwd);
			readIR();*/
		}
	}
}
