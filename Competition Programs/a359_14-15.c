#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S2,     _ir_front,      sensorI2CCustom)
#pragma config(Sensor, S3,     _gyro,          sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     _ir_back,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     lift,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    dragger,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    scorer,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    front_dragger,        tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Assets\Headers\h359_14-15.h"
#include "Assets\Headers\Autonomous_Funcs.h"

#define HTSMUX_SENSORTYPE   0x10

long waitDuration = 0;
long intercept = 0;

int RG1 = 0;
int RG2 = 0;

bool CG = true;
bool fill1;
bool ramp = false;
bool fill2;
bool KS = true;

long KSwait = 0;

int centerRotation; //1 = kickstand facing alliance PZ, 2 = 45, 3 = 90

task liftTask(){
	busy = true;
	moveEncSingle(lift, target_power, target_distance, 1);
	busy = false;
}

void moveLift(int power, long distance){
	target_power = power;
	target_distance = distance;
	startTask(liftTask);
}

bool HTSMUXVerifyType(tSensors link){
    memset(HTSMUX_I2CRequest, 0, sizeof(tByteArray));
    HTSMUX_I2CRequest[0] = 2;
    HTSMUX_I2CRequest[1] = HTSMUX_I2C_ADDR;
    HTSMUX_I2CRequest[2] = HTSMUX_SENSORTYPE;

    if(!writeI2C(link, HTSMUX_I2CRequest, HTSMUX_I2CReply, 8))
        return false;

    if((char)HTSMUX_I2CReply[0] == 'S' && (char)HTSMUX_I2CReply[1] == 'e' &&
       (char)HTSMUX_I2CReply[2] == 'n' && (char)HTSMUX_I2CReply[3] == 's' &&
       (char)HTSMUX_I2CReply[4] == 'r' && (char)HTSMUX_I2CReply[5] == 'M' &&
       (char)HTSMUX_I2CReply[6] == 'U' && (char)HTSMUX_I2CReply[7] == 'X')

        return true;

    return false;
}

void selectStrategy();

task debug(){
	bool ruhroh = false;
	/*if (HTSMUXVerifyType(_SMUX) == false){
		nxtDisplayTextLine(0, "SMUX not connected");
		ruhroh = true;
	}
	if(HTSMUXreadPowerStatus(_SMUX)){
		nxtDisplayTextLine(1, "SMUX low batt");
		ruhroh = true;
	}*/
	if(ruhroh)
		playSound(soundBeepBeep);
	while(true){
		nxtDisplayTextLine(7, "H: %3.1f", heading);
		nxtDisplayTextLine(6, "D: %3.1f", deadband);
	}
}

task main()
{
	configLine("Intercept: ", &intercept, "ms", 0, 100, 7500);
	configLine("Wait: ", &waitDuration, "ms", 0, 100, 10000);
	configLine("RG1: ", &RG1, "cm", 0, 30, 90);
	configLine("RG2: ", &RG2, "cm", 0, 30, 90);
	configLine("", &ramp, "", "Ramp", "PZ");
	configLine("", &CG, "", "CG", "RG");
	configLine("KS: ", &KS, "", "Yes", "No");
	configLine("KS wait: ", &KSwait, "", 0, 100, 5000);
	//startDisplay(true, true, "a359.txt");
	initializeRobot();
	servo[dragger] = DRAGGER_UP;
	servo[front_dragger] = FRONT_DRAGGER_UP;
	servo[scorer] = SCORER_CLOSE;
	bSystemLeaveServosEnabledOnProgramStop = true;
	stopTask(displayDiagnostics);
	wait1Msec(1);
	eraseDisplay();
	startTask(debug);
	wait1Msec(1000);
	calibrateGyro(&gyro, 100);
	startTask(gyroGetHeading);
	startTask(debug);
	//waitForStart();
	stopTask(readMsgFromPC);
	wait1Msec(waitDuration);
	if(intercept){
		move(100, intercept, fwd);
		return;
	}
	heading = 0.0;
	selectStrategy();
	while(true){}
}

void selectStrategy(){
	if(ramp){
	}else{
		if(CG){
			moveEnc(35, 1000, 15, fwd);
			turn_gyro(60, 30, -90.0, 2.0);
			readIR();
			moveEnc(35, 3000, 10, fwd);
			readIR();
			displayTextLine(0, "IRf1: %d", ir_front_dir[0]);
			displayTextLine(1, "IRf2: %d", ir_front_dir[1]);
			displayTextLine(2, "IRb1: %d", ir_back_dir[0]);
			displayTextLine(3, "IRb2: %d", ir_back_dir[1]);
			if((ir_front_dir[0] == 0 || ir_front_dir[0] == 7) &&
				(ir_front_dir[1] == 0 || ir_front_dir[1] == 7) &&
				(ir_back_dir[0] == 0 || (ir_back_dir[0] >= 6 && ir_back_dir[0] <= 7)) &&
				(ir_back_dir[1] == 0 || (ir_back_dir[1] >= 5 && ir_back_dir[1] <= 7)))
				centerRotation = 1;
			nxtDisplayTextLine(4, "CR: %d", centerRotation);
			switch(centerRotation){
				case 1:
					moveLift(30, 10000);
					turn_gyro(60, 30, 90.0, 2.0);
					moveEnc(50, 2000, 15, fwd);
					turn_gyro(60, 30, -90.0, 2.0);
					moveEnc(50, 1750, 15, fwd);
					turn_gyro(60, 30, -90.0, 2.0);
					moveEnc(50, 3750, 15, bwd);
					turn_gyro(60, 30, 90.0, 2.0);
					moveEnc(35, 1250, 15, bwd);
					if(RG1 || RG2)
						servo[scorer] = SCORER_OPEN_AUTO;
					else
						servo[scorer] = SCORER_OPEN_CG;
					wait1Msec(1000);
					servo[scorer] = SCORER_CLOSE;
					moveEnc(35, 2150, 15, fwd);
					moveLift(-20, 5000);
					turn_gyro(60, 30, -90.0, 2.0);
					moveEnc(35, 1000, 15, fwd);
					turn_gyro(60, 30, -90.0, 2.0);
					moveEnc(100, 2000, fwd);
					break;
				default:
					playSound(soundBeepBeep);
					break;
			}
		}
	}
}
