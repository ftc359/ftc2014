#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S2,     _ir_front,      sensorI2CCustom)
#pragma config(Sensor, S3,     _gyro,          sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     _ir_back,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightWheel,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     lift,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    dragger,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    scorer,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    front_dragger,        tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Assets\Headers\h359_14-15.h"
#include "Assets\Headers\Autonomous_Funcs.h"

#define HTSMUX_SENSORTYPE   0x10

long waitDuration = 0;
long intercept = 0;

int RG1 = 60;
int RG2 = 90;

bool CG = false;
bool fill1;
bool ramp = true;
bool fill2;
bool KS = false;

long KSwait = 0;

int centerRotation; //1 = kickstand facing alliance PZ, 2 = 45, 3 = 90

task liftTask(){
	busy = true;
	moveEncSingle(lift, target_power, target_distance, 10);
	busy = false;
}

void moveLift(int power, long distance){
	target_power = power;
	target_distance = distance;
	startTask(liftTask);
}

bool HTSMUXVerifyType(tSensors link){
    memset(HTSMUX_I2CRequest, 0, sizeof(tByteArray));
    HTSMUX_I2CRequest[0] = 2;
    HTSMUX_I2CRequest[1] = HTSMUX_I2C_ADDR;
    HTSMUX_I2CRequest[2] = HTSMUX_SENSORTYPE;

    if(!writeI2C(link, HTSMUX_I2CRequest, HTSMUX_I2CReply, 8))
        return false;

    if((char)HTSMUX_I2CReply[0] == 'S' && (char)HTSMUX_I2CReply[1] == 'e' &&
       (char)HTSMUX_I2CReply[2] == 'n' && (char)HTSMUX_I2CReply[3] == 's' &&
       (char)HTSMUX_I2CReply[4] == 'r' && (char)HTSMUX_I2CReply[5] == 'M' &&
       (char)HTSMUX_I2CReply[6] == 'U' && (char)HTSMUX_I2CReply[7] == 'X')

        return true;

    return false;
}

void selectStrategy();

task debug(){
	bool ruhroh = false;
	/*if (HTSMUXVerifyType(_SMUX) == false){
		nxtDisplayTextLine(0, "SMUX not connected");
		ruhroh = true;
	}
	if(HTSMUXreadPowerStatus(_SMUX)){
		nxtDisplayTextLine(1, "SMUX low batt");
		ruhroh = true;
	}*/
	if(ruhroh)
		playSound(soundBeepBeep);
	while(true){
		nxtDisplayTextLine(1, "H: %3.1f", heading);
		nxtDisplayTextLine(0, "D: %3.1f", deadband);
	}
}

task timer(){
	wait1Msec(20000);
	playSound(soundBeepBeep);
	wait1Msec(10);
	playSound(soundBeepBeep);
	wait1Msec(9990);
	playSound(soundBeepBeep);
	stopAllTasks();
}

task main()
{
	configLine("Intercept: ", &intercept, "ms", 0, 100, 7500);
	configLine("Wait: ", &waitDuration, "ms", 0, 100, 10000);
	configLine("RG1: ", &RG1, "cm", 0, 20, 90);
	configLine("RG2: ", &RG2, "cm", 0, 20, 90);
	configLine("", &ramp, "", "Ramp", "PZ");
	configLine("", &CG, "", "CG", "RG");
	configLine("KS: ", &KS, "", "Yes", "No");
	configLine("KS wait: ", &KSwait, "", 0, 100, 5000);
	//startDisplay(true, true, "a359.txt");
	initializeRobot();
	servo[dragger] = DRAGGER_UP;
	servo[front_dragger] = FRONT_DRAGGER_UP;
	servo[scorer] = 255;
	bSystemLeaveServosEnabledOnProgramStop = true;
	stopTask(displayDiagnostics);
	wait1Msec(1);
	eraseDisplay();
	wait1Msec(999);
	calibrateGyro(&gyro, 100, gyro_bwd);
	startTask(gyroGetHeading);
	startTask(debug);
	waitForStart();
	//startTask(timer);
	stopTask(readMsgFromPC);
	wait1Msec(waitDuration);
	if(intercept){
		move(100, intercept, fwd);
		return;
	}
	heading = 0.0;
	selectStrategy();
	while(true){}
}

void selectStrategy(){
	if(ramp){
		if(CG){
		}else{
			moveEnc(90, 5250, 30, bwd);
			move(20, 1500, fwd);
			heading = 0.0;
			moveLift(100, 4100);
			moveEnc(90, 4000, 30, bwd);
			if(true /*RG1 == 60 && RG2 == 90*/){
				servo[dragger] = DRAGGER_DOWN;
				wait1Msec(500);
				while(busy){}
				servo[scorer] = SCORER_OPEN_AUTO;
				wait1Msec(500);
				servo[scorer] = SCORER_CLOSE;
				moveEnc(90, 1250, 30, fwd);
				turn_gyro(60, 25, 90.0 - heading, 1.0, 2500);
				move(30, 600, fwd);
				wait1Msec(100);
				heading = 90.0;
				moveEnc(50, 850, 30, bwd);
				servo[dragger] = DRAGGER_UP;
				wait1Msec(250);
				moveEnc(50, 350, 30, fwd);
				turn_gyro(30, 15, -heading, 1.0, 3000);
				moveEnc(90, 4250, 25, bwd);
				servo[dragger] = DRAGGER_DOWN;
				moveEnc(90, 1000, 25, fwd);
				turn_gyro(30, 15, -25.0 - heading, 0.5, 2000);
				moveEnc(60, 1250, 25, fwd);
				servo[front_dragger] = FRONT_DRAGGER_DOWN;
				wait1Msec(1000);
				moveEnc(90, 9000, 25, fwd);
				servo[front_dragger] = FRONT_DRAGGER_UP;
				moveLift(100, 3000);
				wait1Msec(250);
				turn_gyro(90, 25, 160.0, 2.0, 2000);
				moveEnc(60, 500, 25, bwd);
				wait1Msec(500);
				servo[scorer] = SCORER_OPEN_RG;
				wait1Msec(2000);
				servo[scorer] = SCORER_CLOSE;
				moveLift(-20, 5000);
			}
		}
	}else{
		if(CG){
			moveEnc(35, 1000, 20, fwd);
			turn_gyro(60, 20, -90.0, 0.5, 2000);
			readIR();
			moveEnc(35, 3000, 20, fwd);
			readIR();
			displayTextLine(0, "IRf1: %d", ir_front_dir[0]);
			displayTextLine(1, "IRf2: %d", ir_front_dir[1]);
			displayTextLine(2, "IRb1: %d", ir_back_dir[0]);
			displayTextLine(3, "IRb2: %d", ir_back_dir[1]);
			if((ir_front_dir[0] == 0 || (ir_front_dir[0] >= 6 && ir_front_dir[0] <= 7)) &&
				(ir_front_dir[1] == 0 || (ir_front_dir[1] >= 5 && ir_front_dir[1] <= 7) || ir_front_dir[1] == 4) &&
				(ir_back_dir[0] == 0 || ir_back_dir[0] == 3 || (ir_back_dir[0] >= 6 && ir_back_dir[0] <= 7)) &&
				(ir_back_dir[1] == 0 || ir_back_dir[1] == 3 || (ir_back_dir[1] >= 5 && ir_back_dir[1] <= 7)))
				centerRotation = 1;
			nxtDisplayTextLine(4, "CR: %d", centerRotation);
			switch(centerRotation){
				case 1:
					turn_gyro(60, 20,  75.0, 0.5, 3000);
					moveEnc(90, 5500, 30, fwd);
					/*moveEnc(90, 2000, 20, fwd);
					moveLift(60, 9750);
					turn_gyro(60, 20, -90.0, 0.5);
					moveEnc(90, 1750, 20, fwd);
					turn_gyro(60, 20, -90.0, 0.5);
					moveEnc(90, 3650, 20, bwd);
					turn_gyro(60, 20, 90.0, 0.5);
					moveEnc(35, 2000, 20, bwd);*/
					/*if(RG1 || RG2)
						servo[scorer] = SCORER_OPEN_AUTO;
					else
						servo[scorer] = SCORER_OPEN_CG;
					wait1Msec(2000);
					servo[scorer] = SCORER_CLOSE;
					moveEnc(90, 1000, 20, fwd);
					moveLift(-20, 9000);
					turn_gyro(60, 20, -90.0, 0.5);
					moveEnc(90, 1000, 20, fwd);
					turn_gyro(60, 20, -90.0, 0.5);
					moveEnc(90, 6000, 20, fwd);*/
					break;
				default:
					playSound(soundBeepBeep);
					break;
			}
		}
	}
}
