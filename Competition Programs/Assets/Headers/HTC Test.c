#pragma config(Sensor, S1,     HTC,            sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Xander's Drivers\common.h"

#define HTC_I2C_ADDR_1      0x02 //Address of the first mtr controller
#define HTC_I2C_ADDR(CHAN)  HTC_I2C_ADDR_1*CHAN

#define HTC_TYPE            0x10

#define HTMC_OFFSET         0x44
#define HTMC_POWER          0x00
#define HTMC_MODE           0x01
#define HTMC_M_ENTRY_SIZE   0x02

#define HTSC_OFFSET					0x41
#define HTSC_POS(CHAN)      0x01*CHAN
#define HTSC_STEP_TIME      0x00

tByteArray HTC_I2CRequest;
tByteArray HTC_I2CReply;

typedef enum{
     S1_C1_1 = 0,
     S1_C1_2 = 1,
     S1_C2_1 = 2,
     S1_C2_2 = 3,
     S1_C3_1 = 4,
     S1_C3_2 = 5,
     S1_C4_1 = 6,
     S1_C4_2 = 7,
     S2_C1_1 = 8,
     S2_C1_2 = 9,
     S2_C2_1 = 10,
     S2_C2_2 = 11,
     S2_C3_1 = 12,
     S2_C3_2 = 13,
     S2_C4_1 = 14,
     S2_C4_2 = 15,
     S3_C1_1 = 16,
     S3_C1_2 = 17,
     S3_C2_1 = 18,
     S3_C2_2 = 19,
     S3_C3_1 = 20,
     S3_C3_2 = 21,
     S3_C4_1 = 22,
     S3_C4_2 = 23,
     S4_C1_1 = 24,
     S4_C1_2 = 25,
     S4_C2_1 = 26,
     S4_C2_2 = 27,
     S4_C3_1 = 28,
     S4_C3_2 = 29,
     S4_C4_1 = 30,
     S4_C4_2 = 31
}tMC;

typedef enum{
     S1_C11 = 0,
     S1_C12 = 1,
     S1_C13 = 2,
     S1_C14 = 3,
     S1_C15 = 4,
     S1_C16 = 5,
     S1_C21 = 6,
     S1_C22 = 7,
     S1_C23 = 8,
     S1_C24 = 9,
     S1_C25 = 10,
     S1_C26 = 11,
     S1_C31 = 12,
     S1_C32 = 13,
     S1_C33 = 14,
     S1_C34 = 15,
     S1_C35 = 16,
     S1_C36 = 17,
     S1_C41 = 18,
     S1_C42 = 19,
     S1_C43 = 20,
     S1_C44 = 21,
     S1_C45 = 22,
     S1_C46 = 23,
     S2_C11 = 24,
     S2_C12 = 25,
     S2_C13 = 26,
     S2_C14 = 27,
     S2_C15 = 28,
     S2_C16 = 29,
     S2_C21 = 30,
     S2_C22 = 31,
     S2_C23 = 32,
     S2_C24 = 33,
     S2_C25 = 34,
     S2_C26 = 35,
     S2_C31 = 36,
     S2_C32 = 37,
     S2_C33 = 38,
     S2_C34 = 39,
     S2_C35 = 40,
     S2_C36 = 41,
     S2_C41 = 42,
     S2_C42 = 43,
     S2_C43 = 44,
     S2_C44 = 45,
     S2_C45 = 46,
     S2_C46 = 47,
     S3_C11 = 48,
     S3_C12 = 49,
     S3_C13 = 50,
     S3_C14 = 51,
     S3_C15 = 52,
     S3_C16 = 53,
     S3_C21 = 54,
     S3_C22 = 55,
     S3_C23 = 56,
     S3_C24 = 57,
     S3_C25 = 58,
     S3_C26 = 59,
     S3_C31 = 60,
     S3_C32 = 61,
     S3_C33 = 62,
     S3_C34 = 63,
     S3_C35 = 64,
     S3_C36 = 65,
     S3_C41 = 66,
     S3_C42 = 67,
     S3_C43 = 68,
     S3_C44 = 69,
     S3_C45 = 70,
     S3_C46 = 71,
     S4_C11 = 72,
     S4_C12 = 73,
     S4_C13 = 74,
     S4_C14 = 75,
     S4_C15 = 76,
     S4_C16 = 77,
     S4_C21 = 78,
     S4_C22 = 79,
     S4_C23 = 80,
     S4_C24 = 81,
     S4_C25 = 82,
     S4_C26 = 83,
     S4_C31 = 84,
     S4_C32 = 85,
     S4_C33 = 86,
     S4_C34 = 87,
     S4_C35 = 88,
     S4_C36 = 89,
     S4_C41 = 90,
     S4_C42 = 91,
     S4_C43 = 92,
     S4_C44 = 93,
     S4_C45 = 94,
     S4_C46 = 95
}tSC;

int HTCVerifyType(tSensors link, ubyte channel){
    memset(HTC_I2CRequest, 0, sizeof(tByteArray));
    HTC_I2CRequest[0] = 2;
    HTC_I2CRequest[1] = HTC_I2C_ADDR(channel);
    HTC_I2CRequest[2] = HTC_TYPE;

    if(!writeI2C(link, HTC_I2CRequest, HTC_I2CReply, 8))
        return -1;

    if((char)HTC_I2CReply[0] == 'M' && (char)HTC_I2CReply[1] == 'o' &&
       (char)HTC_I2CReply[2] == 't' && (char)HTC_I2CReply[3] == 'o' &&
       (char)HTC_I2CReply[4] == 'r' && (char)HTC_I2CReply[5] == 'C' &&
       (char)HTC_I2CReply[6] == 'o' && (char)HTC_I2CReply[7] == 'n')

        return 1;

    if((char)HTC_I2CReply[0] == 'S' && (char)HTC_I2CReply[1] == 'e' &&
       (char)HTC_I2CReply[2] == 'r' && (char)HTC_I2CReply[3] == 'v' &&
       (char)HTC_I2CReply[4] == 'o' && (char)HTC_I2CReply[5] == 'C' &&
       (char)HTC_I2CReply[6] == 'o' && (char)HTC_I2CReply[7] == 'n')

        return 2;

    return 0;
}

bool HTMCPower(tSensors link, tMC mot, byte power){
    memset(HTC_I2CRequest, 0, sizeof(tByteArray));
    int channel = mot%4 + 1;

    HTC_I2CRequest[0] = 3;
    HTC_I2CRequest[1] = HTC_I2C_ADDR(channel);
    HTC_I2CRequest[2] = HTMC_OFFSET + (HTMC_M_ENTRY_SIZE*(mot%2 + 1)) + HTMC_POWER;
    HTC_I2CRequest[3] = ((signed byte)power < -100)?-100:power;

    return writeI2C(link, HTC_I2CRequest);
}

bool HTSCsrvo(tSensors link, tSC ser, ubyte pos){
    memset(HTC_I2CRequest, 0, sizeof(tByteArray));
    int channel = ser%6 + 1;

    HTC_I2CRequest[0] = 3;
    HTC_I2CRequest[1] = HTC_I2C_ADDR(channel);
    HTC_I2CRequest[2] = HTSC_OFFSET + HTSC_POS(channel);
    HTC_I2CRequest[3] = pos;

    return writeI2C(link, HTC_I2CRequest);
}

task main()
{
	nxtDisplayTextLine(1,"%d",HTCVerifyType(HTC,1));
	nxtDisplayTextLine(2,"%d",HTCVerifyType(HTC,2));
	HTMCPower(HTC, S1_C1_1, 20);
	while(true){}
}
