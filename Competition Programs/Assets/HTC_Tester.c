#pragma config(Sensor, S1,     HTC_1,          sensorI2CCustom)
#pragma config(Sensor, S2,     HTC_2,          sensorI2CCustom)
#pragma config(Sensor, S3,     HTC_3,          sensorI2CCustom)
#pragma config(Sensor, S4,     HTC_4,          sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Headers\HTC.h"

int nMenuLevel;
int nPrevMenuLevel;
int nPort;
int nPrevPort;
bool bTransitionFinished = true;

struct mtr{
	int power;
	int prevPower;
};
struct srvo{
	int val;
	int prevVal;
};
struct channel{
	int type;
	int nSelectedLine;
	int nPrevSelectedLine;
	struct mtr mtrs[2];
	struct srvo srvos[6];
};
struct port{
	struct channel chans[4];
	bool available;
	int channel;
	int prevChannel;
};

struct port ports[4];

tSensors HTC(int channel){
	switch(channel){
	case 1:
		return HTC_1;
	case 2:
		return HTC_2;
	case 3:
		return HTC_3;
	case 4:
		return HTC_4;
	}
	return HTC_1;
}
void runMotor(int port, int channel, int mtr, byte power){
	int index = ((port-1)*8)+((channel-1)*2)+(mtr-1);
  HTMCPower(HTC(port), index, power);
}

void runServo(int port, int channel, int ser, byte val){
	int index = ((port-1)*8)+((channel-1)*2)+(ser-1);
	HTSCServo(HTC(port), index, val);
}

int accelerate(int startSpeed, int stopSpeed, long maxTime, long currentTime){
	return ((startSpeed-stopSpeed)/pow(maxTime,2))*pow(currentTime-maxTime,2)+stopSpeed;
}

task updateDisplay();

task main()
{
	string sTemp[4];
	int nMinPort;
	int nMaxPort;
	int nMinChannel;
	int nMaxChannel;

	displayString(3, "Initializing...");
	for(int tPort = 0; tPort < 4; tPort++){
		for(int chain_index = 0; chain_index < 4; chain_index++){
			ports[tPort].chans[chain_index].type = HTCVerifyType(HTC(tPort+1), chain_index+1);
			displayString(5, "%d/4 %d/4", tPort+1, chain_index+1);
			wait1Msec(10);
		}
		ports[tPort].available = (ports[tPort].chans[0].type > 0 || ports[tPort].chans[1].type > 0 || ports[tPort].chans[2].type > 0 || ports[tPort].chans[3].type > 0);
		ports[tPort].channel = (ports[tPort].chans[0].type > 0)?0:(ports[tPort].chans[1].type > 0)?1:(ports[tPort].chans[2].type > 0)?2:3;
		wait1Msec(50);
	}
	eraseDisplay();
	if(!ports[0].available && !ports[1].available && !ports[2].available && !ports[3].available){
		hogCPU();
		playSound(soundBeepBeep);
		displayCenteredTextLine(3, "No Controllers");
		displayCenteredTextLine(4, "Detected!");
		wait1Msec(2000);
		return;
	}
	displayCenteredTextLine(0, "HTCs Detected!");
	for(int tPort = 0; tPort < 4; tPort++){
		for(int chain_index = 0; chain_index < 4; chain_index++){
		sTemp[chain_index] = (ports[tPort].chans[chain_index].type <= 0)?"NA":(ports[tPort].chans[chain_index].type == 1)?"MC":"SC";
		}
		displayCenteredTextLine(1+(tPort*2), "%s  %s  %s  %s", sTemp[0], sTemp[1], sTemp[2], sTemp[3]);
	}
	wait1Msec(3000);

	nMinPort = (ports[0].available)?0:(ports[1].available)?1:(ports[2].available)?2:3;
	nMaxPort = (ports[3].available)?3:(ports[2].available)?2:(ports[1].available)?1:0;
	nPort = nMinPort;
	if(nMinPort == nMaxPort) //Only One Port Available
		nMenuLevel = 1;				 //Skip port selection Process

	startTask(updateDisplay);

	while(true){
		//Port selection

		while(true){
			if(nMenuLevel != 0)
				break;
			if(nPrevMenuLevel != nMenuLevel){
				bTransitionFinished = true;
				nPrevMenuLevel = nMenuLevel;
			}
			if(nNxtButtonPressed == 1){
				do{
					if(++nPort > nMaxPort)
						nPort = nMaxPort;
				}while(!ports[nPort].available);
			}
				while(nNxtButtonPressed == 1){}
			if(nNxtButtonPressed == 2){
				do{
					if(--nPort < nMinPort)
						nPort = nMinPort;
				}while(!ports[nPort].available);
			}
				while(nNxtButtonPressed == 2){}
			if(nNxtButtonPressed == 3){
				while(nNxtButtonPressed == 3){}
				nMenuLevel = 1;
				nNxtExitClicks = 2;
				break;
			}
		}
		//Channel Selection
		nMinChannel = (ports[nPort].chans[0].type > 0)?0:(ports[nPort].chans[1].type > 0)?1:(ports[nPort].chans[2].type > 0)?2:3;
		nMaxChannel = (ports[nPort].chans[3].type > 0)?3:(ports[nPort].chans[2].type > 0)?2:(ports[nPort].chans[1].type > 0)?1:0;

		while(true){
			if(nMenuLevel != 1)
				break;
			if(nMinChannel == nMaxChannel)	//Only One Channel Available
				nMenuLevel = 2;
			if(nPrevMenuLevel != nMenuLevel){
				bTransitionFinished = true;
				nPrevMenuLevel = nMenuLevel;
			}
			if(nNxtButtonPressed == 0){
				while(nNxtButtonPressed == 0){}
				nMenuLevel = 0;
				break;
			}
			if(nNxtButtonPressed == 1){
				do{
					if(++ports[nPort].channel > nMaxChannel)
						ports[nPort].channel = nMaxChannel;
				}while(ports[nPort].chans[ports[nPort].channel].type <= 0);
				while(nNxtButtonPressed == 1){}
			}
			if(nNxtButtonPressed == 2){
				do{
					if(--ports[nPort].channel < nMinChannel)
						ports[nPort].channel = nMinChannel;
				}while(ports[nPort].chans[ports[nPort].channel].type <= 0);
				while(nNxtButtonPressed == 2){}
			}
			if(nNxtButtonPressed == 3){
				while(nNxtButtonPressed == 3){}
				nMenuLevel = 2;
				nNxtExitClicks = 2;
				break;
			}
		}
		//Running
		while(true){
			if(nMenuLevel != 2)
				break;
			if(nPrevMenuLevel != nMenuLevel){
				bTransitionFinished = true;
				nPrevMenuLevel = nMenuLevel;
			}
			if(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 0){
				ports[nPort].chans[ports[nPort].channel].nPrevSelectedLine = 2;
				ports[nPort].chans[ports[nPort].channel].nSelectedLine = 2;
			}
			if(nNxtButtonPressed == 0){
				while(nNxtButtonPressed == 0){}
				nMenuLevel = 1;
				break;
			}
			if(ports[nPort].chans[ports[nPort].channel].type == 1){				//Motor Controller
				if(nNxtButtonPressed == 1){
					clearTimer(T2);
					while(nNxtButtonPressed == 1){
						if(time1[T2] <= 250)
							ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power++;
						else{
							if(ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power%5 != 0)
								ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power += 5-(ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power%5);
							ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power += 5;
						}
						if(ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power > 100)
							ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power = 100;
						if(time1[T2] <= 3000)
							wait1Msec(accelerate(250,75,3000,time1[T2]));
						else
							wait1Msec(75);
					}
				}
				if(nNxtButtonPressed == 2){
					clearTimer(T2);
					while(nNxtButtonPressed == 2){
						if(time1[T2] <= 250)
							ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power--;
						else{
							if(ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power%5 != 0)
								ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power -= (ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power%5);
							ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power -= 5;
						}
						if(ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power < -100)
							ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power = -100;
						if(time1[T2] <= 3000)
							wait1Msec(accelerate(250,75,3000,time1[T2]));
						else
							wait1Msec(75);
					}
				}
				if(nNxtButtonPressed == 3){
					clearTimer(T2);
					while(time1(T2) <= 500 && nNxtButtonPressed != -1){}
					if(time1[T2] <= 500){
						ports[nPort].chans[ports[nPort].channel].nSelectedLine += 2;
						if(ports[nPort].chans[ports[nPort].channel].nSelectedLine > 4)
							ports[nPort].chans[ports[nPort].channel].nSelectedLine = 2;
					}else{
						displayString(6, "Running...");
						stopTask(updateDisplay);
						displayString(2, "Motor 1: %d", ports[nPort].chans[ports[nPort].channel].mtrs[0].power);
						displayString(4, "Motor 2: %d", ports[nPort].chans[ports[nPort].channel].mtrs[1].power);
						while(nNxtButtonPressed == 3){
							runMotor(nPort+1, ports[nPort].channel+1, (ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?1:2, ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power);
						}
						runMotor(nPort+1, ports[nPort].channel+1, (ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?1:2, 0);
						displayClearTextLine(6);
						startTask(updateDisplay);
					}
				}else if(ports[nPort].chans[ports[nPort].channel].type == 2){	//Servo Controller
				}
			}
		}
	}
}

task updateDisplay()
{
	while(true){
		switch(nMenuLevel){
		case 0:
			if(bTransitionFinished || nPrevPort != nPort || time1[T1] > 1000){
				if(bTransitionFinished){
					eraseDisplay();
					nxtDisplayCenteredTextLine(1, "Select A Port");
					bTransitionFinished = false;
				}
				nxtDisplayCenteredTextLine(3, "[S%d]", nPort+1);
				nPrevPort = nPort;
				clearTimer(T1);
				break;
			}
			if(time1[T1] > 500)
				displayClearTextLine(3);
			break;
		case 1:
			if(bTransitionFinished || ports[nPort].prevChannel != ports[nPort].channel || time1[T1] > 1000){
				if(bTransitionFinished){
					eraseDisplay();
					nxtDisplayCenteredTextLine(0, "[S%d]", nPort+1);
					nxtDisplayCenteredTextLine(1, "Select A Channel");
					bTransitionFinished = false;
				}
				nxtDisplayCenteredTextLine(3, "[C%d]", ports[nPort].channel+1);
				ports[nPort].prevChannel = ports[nPort].channel;
				clearTimer(T1);
				break;
			}
			if(time1[T1] > 500)
				displayClearTextLine(3);
			break;
		case 2:
			if(ports[nPort].chans[ports[nPort].channel].type == 1){				//Motor Controller
				if(bTransitionFinished || ports[nPort].chans[ports[nPort].channel].nPrevSelectedLine != ports[nPort].chans[ports[nPort].channel].nSelectedLine ||
					ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].prevPower !=  ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power || time1[T1] > 1000){
					if(bTransitionFinished){
						eraseDisplay();
						nxtDisplayCenteredTextLine(0, "[S%d][C%d]", nPort+1, ports[nPort].channel+1);
						bTransitionFinished = false;
					}
					displayClearTextLine(2);
					displayClearTextLine(4);
					displayString(2, "Motor 1: %d", ports[nPort].chans[ports[nPort].channel].mtrs[0].power);
					displayString(4, "Motor 2: %d", ports[nPort].chans[ports[nPort].channel].mtrs[1].power);
					ports[nPort].chans[ports[nPort].channel].nPrevSelectedLine = ports[nPort].chans[ports[nPort].channel].nSelectedLine;
					ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].prevPower = ports[nPort].chans[ports[nPort].channel].mtrs[(ports[nPort].chans[ports[nPort].channel].nSelectedLine == 2)?0:1].power;
					clearTimer(T1);
					break;
				}
				if(time1[T1] > 500)
					displayClearTextLine(ports[nPort].chans[ports[nPort].channel].nSelectedLine);
			}else if(ports[nPort].chans[ports[nPort].channel].type == 2){	//Servo Controller
			}
			break;
		}
	}
}
